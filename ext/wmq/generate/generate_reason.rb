class GenerateReason

  require 'set'

  #Extract Error Code Constants from Header files  
  def GenerateReason.extract_const(filename, const_prefix)
    @constants = []
    have2 = Set.new
    File.open(filename) do |file|
      file.each do |line|
        line.rstrip!
        # Skip empty and comment lines
        if line.length > 0 && line !~ /^\s*\/\*/
          if match = /\s*#define\s+(#{const_prefix}\w+)[\(\s]+([-\dx]+)/.match(line)
            next if have2.include?(match[2])
            have2.add(match[2])
            @constants << [match[1], match[2]]
          end     # if match
        end     # if non-blank line
      end     # each line
    end     # file
    @constants
  end     # extract_const
  
  #Extract Error Code Constants from Header files  
  # Uses lazy print to collect duplicate values
  def GenerateReason.reason_case(filename, prefix)
    last_rc = nil
    last_reason = nil
    str = ''
    GenerateReason.extract_const(filename,prefix).each do |item|
      if last_rc == item[1]
        str << "        case %-30s: return \"#{item[0]} or #{last_reason}[#{item[1]}]\";\n" % item[0]
        last_rc = nil
        last_reason = nil
      else
        str << "        case %-30s: return \"#{last_reason}[#{last_rc}]\";\n" % last_reason if last_rc
        last_rc = item[1]
        last_reason = item[0]
      end
    end
    str
  end
  
# The WebSphere MQ header files have several duplicate values, 
# so need to exclude duplicates.
  def GenerateReason.selector_case(filename, prefix, excludes=nil, &block)
    GenerateReason.extract_const(filename,prefix).each do |item|
      next if item[0].include?('FIRST') || item[0].include?('LAST')
      next if excludes && excludes.include?(item[0])
      block.call item
    end
  end
  
  def GenerateReason.wmq_reason(path)
    str = <<END_OF_STRING
/* --------------------------------------------------------------------------
 *  Copyright 2006 J. Reid Morrison. Dimension Solutions, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 * --------------------------------------------------------------------------
 *
 *  WARNING: DO NOT MODIFY THIS FILE
 *
 *  This file was generated by generate_reason.rb.
 *
 * --------------------------------------------------------------------------*/

#include "wmq.h"

char* wmq_reason(MQLONG reason_code)
{
    switch (reason_code)
    {
END_OF_STRING

    [['cmqc.h', 'MQRC_'],
     ['cmqcfc.h', 'MQRCCF_']].each do |item|
      str << GenerateReason.reason_case(path+item[0], item[1])
    end
    str << <<END_OF_STRING
    }
    printf("WMQ::wmq_reason Unknown Reason code:%ld\\n",(long)reason_code);
    return "Unknown reason code";
}

END_OF_STRING

    str_switch = ''
    str_id_init = ''
# Integer Selectors for Object Attributes
    [['cmqc.h', 'MQIA_'],
     ['cmqcfc.h', 'MQIACF_', ['MQIACF_ERROR_ID',
                              'MQIACF_QUIESCE']],
     ['cmqcfc.h', 'MQIACH_', ['MQIACH_CURRENT_SEQ_NUMBER', 
                              'MQIACH_BYTES_RCVD', 
                              'MQIACH_BUFFERS_RCVD']],
     ['cmqcfc.h', 'MQIAMO_'],
     ['cmqcfc.h', 'MQIAMO64_',  ['MQIAMO64_AVG_Q_TIME',
                                                    'MQIAMO64_Q_TIME_AVG',
                                                    'MQIAMO64_Q_TIME_MAX',
                                                    'MQIAMO64_Q_TIME_MIN']],
# Integer System Selectors
     ['cmqbc.h', 'MQIASY_'],
# Character Selectors for Object Attributes
     ['cmqc.h', 'MQCA_',['MQCA_BASE_OBJECT_NAME']],
     ['cmqcfc.h', 'MQCACF_'],
     ['cmqcfc.h', 'MQCACH_'],
     ['cmqcfc.h', 'MQCAMO_'],
# Byte String Selectors for Object Attributes
     ['cmqc.h', 'MQBA_'],
     ['cmqcfc.h', 'MQBACF_'],
# Group Selectors for Object Attributes
     ['cmqcfc.h', 'MQGACF_'] ].each do |item|
      str << "/* Constants #{item[1]}* from #{item[0]} */\n"
      str_switch << "        /* Constants #{item[1]}* from #{item[0]} */\n"
      str_id_init << "    /* Constants #{item[1]}* from #{item[0]} */\n"
      GenerateReason.selector_case(path+item[0], item[1], item[2]) do |const|
        id = const[0].gsub(item[1],'').downcase
        str_switch << "        case %-30s: return ID_#{id};\n" % const[0]
        str_id_init << "    ID_%-25s = rb_intern(\"#{id}\");\n" % id
        str << "static ID ID_#{id};\n"
      end        
    end

    str << <<END_OF_STRING

void QueueManager_selector_id_init()
{
#{str_id_init}
}

ID wmq_selector_id(MQLONG selector)
{
    switch (selector)
    {
#{str_switch}
    }
    printf("WMQ::wmq_select_text Unknown Selector:%ld\\n",(long)selector);
    return rb_intern("unknown_selector_code");
}

void wmq_selector(ID selector_id, PMQLONG selector_type, PMQLONG selector)
{
    *selector_type = MQIT_INTEGER;
END_OF_STRING
    first = true
    str_if = ''
    str_id_init = ''
# Integer Selectors for Object Attributes
    [['cmqc.h',   'MQIA_'],
     ['cmqcfc.h', 'MQIACF_', ['MQIACF_ERROR_ID',
                                              'MQIACF_QUIESCE']],
     ['cmqcfc.h', 'MQIACH_', ['MQIACH_CURRENT_SEQ_NUMBER', 
                                              'MQIACH_BYTES_RCVD', 
                                              'MQIACH_BUFFERS_RCVD']],
     ['cmqcfc.h', 'MQIAMO_'],
     ['cmqcfc.h', 'MQIAMO64_',  ['MQIAMO64_AVG_Q_TIME',
                                                    'MQIAMO64_Q_TIME_AVG',
                                                    'MQIAMO64_Q_TIME_MAX',
                                                    'MQIAMO64_Q_TIME_MIN']],
# Integer System Selectors
#     ['cmqbc.h', 'MQIASY_'],
    ].each do |item|
      str << "    /* Consteants #{item[1]}* from #{item[0]} */\n"
      GenerateReason.selector_case(path+item[0], item[1], item[2]) do |const|
        str << "    if(selector_id == %-32s{ *selector = #{const[0]}; return;}\n" % "ID_#{const[0].gsub(item[1],'').downcase})" 
      end        
    end
    str << "\n    *selector_type = MQIT_STRING;\n\n"
# Character Selectors for Object Attributes
   [['cmqc.h', 'MQCA_',['MQCA_BASE_OBJECT_NAME']],
     ['cmqcfc.h', 'MQCACF_'],
     ['cmqcfc.h', 'MQCACH_'],
     ['cmqcfc.h', 'MQCAMO_'],
# Byte String Selectors for Object Attributes
#     ['cmqc.h', 'MQBA_'],
#     ['cmqcfc.h', 'MQBACF_'],
# Group Selectors for Object Attributes
#     ['cmqcfc.h', 'MQGACF_'] 
    ].each do |item|
      str << "    /* Constants #{item[1]}* from #{item[0]} */\n"
      GenerateReason.selector_case(path+item[0], item[1], item[2]) do |const|
        str << "    if(selector_id == %-32s{ *selector = #{const[0]}; return;}\n" % "ID_#{const[0].gsub(item[1],'').downcase})" 
      end        
    end

    str << <<END_OF_STRING
    
    rb_raise(rb_eArgError, "WMQ::QueueManager#execute [wmq_selector] Unknown selector supplied");
}

END_OF_STRING
      first = true
      str_if = ''
      str_id_init = ''
      GenerateReason.selector_case(path+'cmqcfc.h', 'MQCMD_') do |const|
        if first
          first = false
          str_if << "    "
        else
          str_if << "    else "
        end
        id = const[0].gsub('MQCMD_','').downcase
        str_id_init << "    ID_%-25s = rb_intern(\"#{id}\");\n" % id
        str_if << "if(command_id == %-28s{ command = #{const[0]}; }\n" % "ID_#{const[0].gsub('MQCMD_','').downcase})" 
        str << "static ID ID_#{id};\n"
      end        
    str << <<END_OF_STRING

void QueueManager_command_id_init()
{
#{str_id_init}
}

MQLONG wmq_command_lookup(ID command_id)
{
    MQLONG command = 0;
#{str_if}    
    else
    {
        rb_raise(rb_eArgError, "WMQ::QueueManager#execute [wmq_command_lookup] Unknown command supplied");
    }

    return command;
}
END_OF_STRING
  str
  end
  
  def self.generate(path)
    File.open('wmq_reason.c', 'w') {|file| file.write(GenerateReason.wmq_reason(path))}
    puts 'Generated wmq_reason.c'
  end
end

if $0 == __FILE__
  path = ARGV[0] || raise("Mandatory parameter: 'WebSphere MQ Include path' is missing")
  path = path + '/'
  GenerateReason.generate(path)
end
