
/* --------------------------------------------------------------------------
 *  Copyright 2006 J. Reid Morrison. Dimension Solutions, Inc.
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 * --------------------------------------------------------------------------
 *
 *  WARNING: DO NOT MODIFY THIS FILE
 *
 *  This file was generated by generate_structs.rb.
 *
 * --------------------------------------------------------------------------*/

#include "wmq.h"

/* --------------------------------------------------------------------------
 *  Static's to hold Symbols
 * --------------------------------------------------------------------------*/
static ID ID_abend_code;
static ID ID_accounting_token;
static ID ID_ads_descriptor;
static ID ID_appl_id;
static ID ID_appl_identity_data;
static ID ID_appl_origin_data;
static ID ID_appl_type;
static ID ID_attention_id;
static ID ID_authenticator;
static ID ID_backout_count;
static ID ID_cancel_code;
static ID ID_cics;
static ID ID_coded_char_set_id;
static ID ID_commit_mode;
static ID ID_comp_code;
static ID ID_conversational_task;
static ID ID_correl_id;
static ID ID_cursor_position;
static ID ID_data_set;
static ID ID_data_logical_length;
static ID ID_data_logical_offset;
static ID ID_data_logical_offset2;
static ID ID_dead_letter_header;
static ID ID_descriptor_set;
static ID ID_dest_env_length;
static ID ID_dest_env_offset;
static ID ID_dest_name_length;
static ID ID_dest_name_offset;
static ID ID_dest_q_mgr_name;
static ID ID_dest_q_name;
static ID ID_dist_header;
static ID ID_encoding;
static ID ID_env_data;
static ID ID_error_offset;
static ID ID_expiry;
static ID ID_facility;
static ID ID_facility_keep_time;
static ID ID_facility_like;
static ID ID_feedback;
static ID ID_flags;
static ID ID_format;
static ID ID_function;
static ID ID_get_wait_interval;
static ID ID_group_id;
static ID ID_header_type;
static ID ID_headers_set;
static ID ID_ims;
static ID ID_input_item;
static ID ID_l_term_override;
static ID ID_link_type;
static ID ID_mfs_map_name;
static ID ID_msg_desc;
static ID ID_msg_flags;
static ID ID_msg_id;
static ID ID_msg_seq_number;
static ID ID_msg_token;
static ID ID_msg_type;
static ID ID_name_value;
static ID ID_name_value_ccsid;
static ID ID_next_transaction_id;
static ID ID_object_instance_id;
static ID ID_object_rec_offset;
static ID ID_object_type;
static ID ID_offset;
static ID ID_original_length;
static ID ID_output_data_length;
static ID ID_persistence;
static ID ID_priority;
static ID ID_process_name;
static ID ID_put_appl_name;
static ID ID_put_appl_type;
static ID ID_put_date;
static ID ID_put_msg_rec_fields;
static ID ID_put_msg_rec_offset;
static ID ID_put_time;
static ID ID_q_mgr_name;
static ID ID_q_name;
static ID ID_reason;
static ID ID_recs_present;
static ID ID_ref_msg_header;
static ID ID_remote_q_mgr_name;
static ID ID_remote_q_name;
static ID ID_remote_sys_id;
static ID ID_remote_trans_id;
static ID ID_reply_to_format;
static ID ID_reply_to_q;
static ID ID_reply_to_q_mgr;
static ID ID_report;
static ID ID_reserved;
static ID ID_reserved1;
static ID ID_reserved2;
static ID ID_reserved3;
static ID ID_reserved4;
static ID ID_return_code;
static ID ID_rf_header;
static ID ID_rf_header_2;
static ID ID_security_scope;
static ID ID_service_name;
static ID ID_service_step;
static ID ID_src_env_length;
static ID ID_src_env_offset;
static ID ID_src_name_length;
static ID ID_src_name_offset;
static ID ID_start_code;
static ID ID_task_end_status;
static ID ID_to_s;
static ID ID_tran_instance_id;
static ID ID_tran_state;
static ID ID_transaction_id;
static ID ID_trigger;
static ID ID_trigger_data;
static ID ID_uow_control;
static ID ID_user_data;
static ID ID_user_identifier;
static ID ID_work_info_header;
static ID ID_xmit_q_header;
static ID ID_xml;

/* --------------------------------------------------------------------------
 *  Initialize Symbols
 * --------------------------------------------------------------------------*/
void wmq_structs_id_init()
{
    ID_abend_code           = rb_intern("abend_code");
    ID_accounting_token     = rb_intern("accounting_token");
    ID_ads_descriptor       = rb_intern("ads_descriptor");
    ID_appl_id              = rb_intern("appl_id");
    ID_appl_identity_data   = rb_intern("appl_identity_data");
    ID_appl_origin_data     = rb_intern("appl_origin_data");
    ID_appl_type            = rb_intern("appl_type");
    ID_attention_id         = rb_intern("attention_id");
    ID_authenticator        = rb_intern("authenticator");
    ID_backout_count        = rb_intern("backout_count");
    ID_cancel_code          = rb_intern("cancel_code");
    ID_cics                 = rb_intern("cics");
    ID_coded_char_set_id    = rb_intern("coded_char_set_id");
    ID_commit_mode          = rb_intern("commit_mode");
    ID_comp_code            = rb_intern("comp_code");
    ID_conversational_task  = rb_intern("conversational_task");
    ID_correl_id            = rb_intern("correl_id");
    ID_cursor_position      = rb_intern("cursor_position");
    ID_data_set             = rb_intern("data=");
    ID_data_logical_length  = rb_intern("data_logical_length");
    ID_data_logical_offset  = rb_intern("data_logical_offset");
    ID_data_logical_offset2 = rb_intern("data_logical_offset2");
    ID_dead_letter_header   = rb_intern("dead_letter_header");
    ID_descriptor_set       = rb_intern("descriptor=");
    ID_dest_env_length      = rb_intern("dest_env_length");
    ID_dest_env_offset      = rb_intern("dest_env_offset");
    ID_dest_name_length     = rb_intern("dest_name_length");
    ID_dest_name_offset     = rb_intern("dest_name_offset");
    ID_dest_q_mgr_name      = rb_intern("dest_q_mgr_name");
    ID_dest_q_name          = rb_intern("dest_q_name");
    ID_dist_header          = rb_intern("dist_header");
    ID_encoding             = rb_intern("encoding");
    ID_env_data             = rb_intern("env_data");
    ID_error_offset         = rb_intern("error_offset");
    ID_expiry               = rb_intern("expiry");
    ID_facility             = rb_intern("facility");
    ID_facility_keep_time   = rb_intern("facility_keep_time");
    ID_facility_like        = rb_intern("facility_like");
    ID_feedback             = rb_intern("feedback");
    ID_flags                = rb_intern("flags");
    ID_format               = rb_intern("format");
    ID_function             = rb_intern("function");
    ID_get_wait_interval    = rb_intern("get_wait_interval");
    ID_group_id             = rb_intern("group_id");
    ID_header_type          = rb_intern("header_type");
    ID_headers_set          = rb_intern("headers=");
    ID_ims                  = rb_intern("ims");
    ID_input_item           = rb_intern("input_item");
    ID_l_term_override      = rb_intern("l_term_override");
    ID_link_type            = rb_intern("link_type");
    ID_mfs_map_name         = rb_intern("mfs_map_name");
    ID_msg_desc             = rb_intern("msg_desc");
    ID_msg_flags            = rb_intern("msg_flags");
    ID_msg_id               = rb_intern("msg_id");
    ID_msg_seq_number       = rb_intern("msg_seq_number");
    ID_msg_token            = rb_intern("msg_token");
    ID_msg_type             = rb_intern("msg_type");
    ID_name_value           = rb_intern("name_value");
    ID_name_value_ccsid     = rb_intern("name_value_ccsid");
    ID_next_transaction_id  = rb_intern("next_transaction_id");
    ID_object_instance_id   = rb_intern("object_instance_id");
    ID_object_rec_offset    = rb_intern("object_rec_offset");
    ID_object_type          = rb_intern("object_type");
    ID_offset               = rb_intern("offset");
    ID_original_length      = rb_intern("original_length");
    ID_output_data_length   = rb_intern("output_data_length");
    ID_persistence          = rb_intern("persistence");
    ID_priority             = rb_intern("priority");
    ID_process_name         = rb_intern("process_name");
    ID_put_appl_name        = rb_intern("put_appl_name");
    ID_put_appl_type        = rb_intern("put_appl_type");
    ID_put_date             = rb_intern("put_date");
    ID_put_msg_rec_fields   = rb_intern("put_msg_rec_fields");
    ID_put_msg_rec_offset   = rb_intern("put_msg_rec_offset");
    ID_put_time             = rb_intern("put_time");
    ID_q_mgr_name           = rb_intern("q_mgr_name");
    ID_q_name               = rb_intern("q_name");
    ID_reason               = rb_intern("reason");
    ID_recs_present         = rb_intern("recs_present");
    ID_ref_msg_header       = rb_intern("ref_msg_header");
    ID_remote_q_mgr_name    = rb_intern("remote_q_mgr_name");
    ID_remote_q_name        = rb_intern("remote_q_name");
    ID_remote_sys_id        = rb_intern("remote_sys_id");
    ID_remote_trans_id      = rb_intern("remote_trans_id");
    ID_reply_to_format      = rb_intern("reply_to_format");
    ID_reply_to_q           = rb_intern("reply_to_q");
    ID_reply_to_q_mgr       = rb_intern("reply_to_q_mgr");
    ID_report               = rb_intern("report");
    ID_reserved             = rb_intern("reserved");
    ID_reserved1            = rb_intern("reserved1");
    ID_reserved2            = rb_intern("reserved2");
    ID_reserved3            = rb_intern("reserved3");
    ID_reserved4            = rb_intern("reserved4");
    ID_return_code          = rb_intern("return_code");
    ID_rf_header            = rb_intern("rf_header");
    ID_rf_header_2          = rb_intern("rf_header_2");
    ID_security_scope       = rb_intern("security_scope");
    ID_service_name         = rb_intern("service_name");
    ID_service_step         = rb_intern("service_step");
    ID_src_env_length       = rb_intern("src_env_length");
    ID_src_env_offset       = rb_intern("src_env_offset");
    ID_src_name_length      = rb_intern("src_name_length");
    ID_src_name_offset      = rb_intern("src_name_offset");
    ID_start_code           = rb_intern("start_code");
    ID_task_end_status      = rb_intern("task_end_status");
    ID_to_s                 = rb_intern("to_s");
    ID_tran_instance_id     = rb_intern("tran_instance_id");
    ID_tran_state           = rb_intern("tran_state");
    ID_transaction_id       = rb_intern("transaction_id");
    ID_trigger              = rb_intern("trigger");
    ID_trigger_data         = rb_intern("trigger_data");
    ID_uow_control          = rb_intern("uow_control");
    ID_user_data            = rb_intern("user_data");
    ID_user_identifier      = rb_intern("user_identifier");
    ID_work_info_header     = rb_intern("work_info_header");
    ID_xmit_q_header        = rb_intern("xmit_q_header");
    ID_xml                  = rb_intern("xml");
}

/* --------------------------------------------------------------------------
 *  Convert between MQMD and Hash
 * --------------------------------------------------------------------------*/
void Message_from_mqmd(VALUE hash, MQMD* pmqmd)
{
    VALUE  str;
    size_t size;
    size_t length; 
    size_t i;
    char*  pChar;
        
    WMQ_MQLONG2HASH (hash, report,                        pmqmd->Report)
    WMQ_MQLONG2HASH (hash, msg_type,                      pmqmd->MsgType)
    WMQ_MQLONG2HASH (hash, expiry,                        pmqmd->Expiry)
    WMQ_MQLONG2HASH (hash, feedback,                      pmqmd->Feedback)
    WMQ_MQLONG2HASH (hash, encoding,                      pmqmd->Encoding)
    WMQ_MQLONG2HASH (hash, coded_char_set_id,             pmqmd->CodedCharSetId)
    WMQ_MQCHARS2HASH(hash, format,                        pmqmd->Format)
    WMQ_MQLONG2HASH (hash, priority,                      pmqmd->Priority)
    WMQ_MQLONG2HASH (hash, persistence,                   pmqmd->Persistence)
    WMQ_MQBYTES2HASH(hash, msg_id,                        pmqmd->MsgId)
    WMQ_MQBYTES2HASH(hash, correl_id,                     pmqmd->CorrelId)
    WMQ_MQLONG2HASH (hash, backout_count,                 pmqmd->BackoutCount)
    WMQ_MQCHARS2HASH(hash, reply_to_q,                    pmqmd->ReplyToQ)
    WMQ_MQCHARS2HASH(hash, reply_to_q_mgr,                pmqmd->ReplyToQMgr)
    WMQ_MQCHARS2HASH(hash, user_identifier,               pmqmd->UserIdentifier)
    WMQ_MQBYTES2HASH(hash, accounting_token,              pmqmd->AccountingToken)
    WMQ_MQCHARS2HASH(hash, appl_identity_data,            pmqmd->ApplIdentityData)
    WMQ_MQLONG2HASH (hash, put_appl_type,                 pmqmd->PutApplType)
    WMQ_MQCHARS2HASH(hash, put_appl_name,                 pmqmd->PutApplName)
    WMQ_MQCHARS2HASH(hash, put_date,                      pmqmd->PutDate)
    WMQ_MQCHARS2HASH(hash, put_time,                      pmqmd->PutTime)
    WMQ_MQCHARS2HASH(hash, appl_origin_data,              pmqmd->ApplOriginData)
    WMQ_MQBYTES2HASH(hash, group_id,                      pmqmd->GroupId)
    WMQ_MQLONG2HASH (hash, msg_seq_number,                pmqmd->MsgSeqNumber)
    WMQ_MQLONG2HASH (hash, offset,                        pmqmd->Offset)
    WMQ_MQLONG2HASH (hash, msg_flags,                     pmqmd->MsgFlags)
    WMQ_MQLONG2HASH (hash, original_length,               pmqmd->OriginalLength)
}

static int Message_to_mqmd_each (VALUE key, VALUE value, MQMD* pmqmd)
{
    VALUE str;
    size_t size;
    size_t length; 
    VALUE  val;
    ID     id = rb_to_id(key);
    
    if(id == ID_report)                { WMQ_STR2MQLONG  (value,pmqmd->Report) }
    else if(id == ID_msg_type)              { WMQ_STR2MQLONG  (value,pmqmd->MsgType) }
    else if(id == ID_expiry)                { WMQ_STR2MQLONG  (value,pmqmd->Expiry) }
    else if(id == ID_feedback)              { WMQ_STR2MQLONG  (value,pmqmd->Feedback) }
    else if(id == ID_encoding)              { WMQ_STR2MQLONG  (value,pmqmd->Encoding) }
    else if(id == ID_coded_char_set_id)     { WMQ_STR2MQLONG  (value,pmqmd->CodedCharSetId) }
    else if(id == ID_format)                { WMQ_STR2MQCHARS (value,pmqmd->Format) }
    else if(id == ID_priority)              { WMQ_STR2MQLONG  (value,pmqmd->Priority) }
    else if(id == ID_persistence)           { WMQ_STR2MQLONG  (value,pmqmd->Persistence) }
    else if(id == ID_msg_id)                { WMQ_STR2MQBYTES (value,pmqmd->MsgId) }
    else if(id == ID_correl_id)             { WMQ_STR2MQBYTES (value,pmqmd->CorrelId) }
    else if(id == ID_backout_count)         { WMQ_STR2MQLONG  (value,pmqmd->BackoutCount) }
    else if(id == ID_reply_to_q)            { WMQ_STR2MQCHARS (value,pmqmd->ReplyToQ) }
    else if(id == ID_reply_to_q_mgr)        { WMQ_STR2MQCHARS (value,pmqmd->ReplyToQMgr) }
    else if(id == ID_user_identifier)       { WMQ_STR2MQCHARS (value,pmqmd->UserIdentifier) }
    else if(id == ID_accounting_token)      { WMQ_STR2MQBYTES (value,pmqmd->AccountingToken) }
    else if(id == ID_appl_identity_data)    { WMQ_STR2MQCHARS (value,pmqmd->ApplIdentityData) }
    else if(id == ID_put_appl_type)         { WMQ_STR2MQLONG  (value,pmqmd->PutApplType) }
    else if(id == ID_put_appl_name)         { WMQ_STR2MQCHARS (value,pmqmd->PutApplName) }
    else if(id == ID_put_date)              { WMQ_STR2MQCHARS (value,pmqmd->PutDate) }
    else if(id == ID_put_time)              { WMQ_STR2MQCHARS (value,pmqmd->PutTime) }
    else if(id == ID_appl_origin_data)      { WMQ_STR2MQCHARS (value,pmqmd->ApplOriginData) }
    else if(id == ID_group_id)              { WMQ_STR2MQBYTES (value,pmqmd->GroupId) }
    else if(id == ID_msg_seq_number)        { WMQ_STR2MQLONG  (value,pmqmd->MsgSeqNumber) }
    else if(id == ID_offset)                { WMQ_STR2MQLONG  (value,pmqmd->Offset) }
    else if(id == ID_msg_flags)             { WMQ_STR2MQLONG  (value,pmqmd->MsgFlags) }
    else if(id == ID_original_length)       { WMQ_STR2MQLONG  (value,pmqmd->OriginalLength) }
    else
    {
        val = rb_funcall(key, ID_to_s, 0);
        rb_raise(rb_eArgError, "WMQ::Message#to_mqmd Unknown symbol :%s supplied", RSTRING_PTR(val));
    }

    return 0;
}

void Message_to_mqmd(VALUE hash, MQMD* pmqmd)
{
    rb_hash_foreach(hash, Message_to_mqmd_each, (VALUE)pmqmd);
}

/* --------------------------------------------------------------------------
 *  Convert between MQMD1 and Hash
 * --------------------------------------------------------------------------*/
void Message_from_mqmd1(VALUE hash, MQMD1* pmqmd1)
{
    VALUE  str;
    size_t size;
    size_t length; 
    size_t i;
    char*  pChar;
        
    WMQ_MQLONG2HASH (hash, report,                        pmqmd1->Report)
    WMQ_MQLONG2HASH (hash, msg_type,                      pmqmd1->MsgType)
    WMQ_MQLONG2HASH (hash, expiry,                        pmqmd1->Expiry)
    WMQ_MQLONG2HASH (hash, feedback,                      pmqmd1->Feedback)
    WMQ_MQLONG2HASH (hash, encoding,                      pmqmd1->Encoding)
    WMQ_MQLONG2HASH (hash, coded_char_set_id,             pmqmd1->CodedCharSetId)
    WMQ_MQCHARS2HASH(hash, format,                        pmqmd1->Format)
    WMQ_MQLONG2HASH (hash, priority,                      pmqmd1->Priority)
    WMQ_MQLONG2HASH (hash, persistence,                   pmqmd1->Persistence)
    WMQ_MQBYTES2HASH(hash, msg_id,                        pmqmd1->MsgId)
    WMQ_MQBYTES2HASH(hash, correl_id,                     pmqmd1->CorrelId)
    WMQ_MQLONG2HASH (hash, backout_count,                 pmqmd1->BackoutCount)
    WMQ_MQCHARS2HASH(hash, reply_to_q,                    pmqmd1->ReplyToQ)
    WMQ_MQCHARS2HASH(hash, reply_to_q_mgr,                pmqmd1->ReplyToQMgr)
    WMQ_MQCHARS2HASH(hash, user_identifier,               pmqmd1->UserIdentifier)
    WMQ_MQBYTES2HASH(hash, accounting_token,              pmqmd1->AccountingToken)
    WMQ_MQCHARS2HASH(hash, appl_identity_data,            pmqmd1->ApplIdentityData)
    WMQ_MQLONG2HASH (hash, put_appl_type,                 pmqmd1->PutApplType)
    WMQ_MQCHARS2HASH(hash, put_appl_name,                 pmqmd1->PutApplName)
    WMQ_MQCHARS2HASH(hash, put_date,                      pmqmd1->PutDate)
    WMQ_MQCHARS2HASH(hash, put_time,                      pmqmd1->PutTime)
    WMQ_MQCHARS2HASH(hash, appl_origin_data,              pmqmd1->ApplOriginData)
}

static int Message_to_mqmd1_each (VALUE key, VALUE value, MQMD1* pmqmd1)
{
    VALUE str;
    size_t size;
    size_t length; 
    VALUE  val;
    ID     id = rb_to_id(key);
    
    if(id == ID_report)                { WMQ_STR2MQLONG  (value,pmqmd1->Report) }
    else if(id == ID_msg_type)              { WMQ_STR2MQLONG  (value,pmqmd1->MsgType) }
    else if(id == ID_expiry)                { WMQ_STR2MQLONG  (value,pmqmd1->Expiry) }
    else if(id == ID_feedback)              { WMQ_STR2MQLONG  (value,pmqmd1->Feedback) }
    else if(id == ID_encoding)              { WMQ_STR2MQLONG  (value,pmqmd1->Encoding) }
    else if(id == ID_coded_char_set_id)     { WMQ_STR2MQLONG  (value,pmqmd1->CodedCharSetId) }
    else if(id == ID_format)                { WMQ_STR2MQCHARS (value,pmqmd1->Format) }
    else if(id == ID_priority)              { WMQ_STR2MQLONG  (value,pmqmd1->Priority) }
    else if(id == ID_persistence)           { WMQ_STR2MQLONG  (value,pmqmd1->Persistence) }
    else if(id == ID_msg_id)                { WMQ_STR2MQBYTES (value,pmqmd1->MsgId) }
    else if(id == ID_correl_id)             { WMQ_STR2MQBYTES (value,pmqmd1->CorrelId) }
    else if(id == ID_backout_count)         { WMQ_STR2MQLONG  (value,pmqmd1->BackoutCount) }
    else if(id == ID_reply_to_q)            { WMQ_STR2MQCHARS (value,pmqmd1->ReplyToQ) }
    else if(id == ID_reply_to_q_mgr)        { WMQ_STR2MQCHARS (value,pmqmd1->ReplyToQMgr) }
    else if(id == ID_user_identifier)       { WMQ_STR2MQCHARS (value,pmqmd1->UserIdentifier) }
    else if(id == ID_accounting_token)      { WMQ_STR2MQBYTES (value,pmqmd1->AccountingToken) }
    else if(id == ID_appl_identity_data)    { WMQ_STR2MQCHARS (value,pmqmd1->ApplIdentityData) }
    else if(id == ID_put_appl_type)         { WMQ_STR2MQLONG  (value,pmqmd1->PutApplType) }
    else if(id == ID_put_appl_name)         { WMQ_STR2MQCHARS (value,pmqmd1->PutApplName) }
    else if(id == ID_put_date)              { WMQ_STR2MQCHARS (value,pmqmd1->PutDate) }
    else if(id == ID_put_time)              { WMQ_STR2MQCHARS (value,pmqmd1->PutTime) }
    else if(id == ID_appl_origin_data)      { WMQ_STR2MQCHARS (value,pmqmd1->ApplOriginData) }
    else if(id == ID_remote_q_name) {}
    else if(id == ID_remote_q_mgr_name) {}
    else
    {
        val = rb_funcall(key, ID_to_s, 0);
        rb_raise(rb_eArgError, "WMQ::Message#to_mqmd1 Unknown symbol :%s supplied", RSTRING_PTR(val));
    }

    return 0;
}

void Message_to_mqmd1(VALUE hash, MQMD1* pmqmd1)
{
    rb_hash_foreach(hash, Message_to_mqmd1_each, (VALUE)pmqmd1);
}

/* --------------------------------------------------------------------------
 *  Convert between MQRFH2 and Hash
 * --------------------------------------------------------------------------*/
void Message_from_mqrfh2(VALUE hash, MQRFH2* pmqrfh2)
{
    VALUE  str;
    size_t size;
    size_t length; 
    size_t i;
    char*  pChar;
        
    WMQ_MQLONG2HASH (hash, encoding,                      pmqrfh2->Encoding)
    WMQ_MQLONG2HASH (hash, coded_char_set_id,             pmqrfh2->CodedCharSetId)
    WMQ_MQLONG2HASH (hash, flags,                         pmqrfh2->Flags)
    WMQ_MQLONG2HASH (hash, name_value_ccsid,              pmqrfh2->NameValueCCSID)
}

static int Message_to_mqrfh2_each (VALUE key, VALUE value, MQRFH2* pmqrfh2)
{
    VALUE str;
    size_t size;
    size_t length; 
    VALUE  val;
    ID     id = rb_to_id(key);
    
    if(id == ID_encoding)              { WMQ_STR2MQLONG  (value,pmqrfh2->Encoding) }
    else if(id == ID_coded_char_set_id)     { WMQ_STR2MQLONG  (value,pmqrfh2->CodedCharSetId) }
    else if(id == ID_flags)                 { WMQ_STR2MQLONG  (value,pmqrfh2->Flags) }
    else if(id == ID_name_value_ccsid)      { WMQ_STR2MQLONG  (value,pmqrfh2->NameValueCCSID) }
    else if(id == ID_xml) {}
    else if(id != ID_header_type)
    {
        val = rb_funcall(key, ID_to_s, 0);
        rb_raise(rb_eArgError, "WMQ::Message#to_mqrfh2 Unknown symbol :%s supplied", RSTRING_PTR(val));
    }

    return 0;
}

void Message_to_mqrfh2(VALUE hash, MQRFH2* pmqrfh2)
{
    rb_hash_foreach(hash, Message_to_mqrfh2_each, (VALUE)pmqrfh2);
}

/* --------------------------------------------------------------------------
 *  Convert between MQRFH and Hash
 * --------------------------------------------------------------------------*/
void Message_from_mqrfh(VALUE hash, MQRFH* pmqrfh)
{
    VALUE  str;
    size_t size;
    size_t length; 
    size_t i;
    char*  pChar;
        
    WMQ_MQLONG2HASH (hash, encoding,                      pmqrfh->Encoding)
    WMQ_MQLONG2HASH (hash, coded_char_set_id,             pmqrfh->CodedCharSetId)
    WMQ_MQLONG2HASH (hash, flags,                         pmqrfh->Flags)
}

static int Message_to_mqrfh_each (VALUE key, VALUE value, MQRFH* pmqrfh)
{
    VALUE str;
    size_t size;
    size_t length; 
    VALUE  val;
    ID     id = rb_to_id(key);
    
    if(id == ID_encoding)              { WMQ_STR2MQLONG  (value,pmqrfh->Encoding) }
    else if(id == ID_coded_char_set_id)     { WMQ_STR2MQLONG  (value,pmqrfh->CodedCharSetId) }
    else if(id == ID_flags)                 { WMQ_STR2MQLONG  (value,pmqrfh->Flags) }
    else if(id == ID_name_value) {}
    else if(id != ID_header_type)
    {
        val = rb_funcall(key, ID_to_s, 0);
        rb_raise(rb_eArgError, "WMQ::Message#to_mqrfh Unknown symbol :%s supplied", RSTRING_PTR(val));
    }

    return 0;
}

void Message_to_mqrfh(VALUE hash, MQRFH* pmqrfh)
{
    rb_hash_foreach(hash, Message_to_mqrfh_each, (VALUE)pmqrfh);
}

/* --------------------------------------------------------------------------
 *  Convert between MQDLH and Hash
 * --------------------------------------------------------------------------*/
void Message_from_mqdlh(VALUE hash, MQDLH* pmqdlh)
{
    VALUE  str;
    size_t size;
    size_t length; 
    size_t i;
    char*  pChar;
        
    WMQ_MQLONG2HASH (hash, reason,                        pmqdlh->Reason)
    WMQ_MQCHARS2HASH(hash, dest_q_name,                   pmqdlh->DestQName)
    WMQ_MQCHARS2HASH(hash, dest_q_mgr_name,               pmqdlh->DestQMgrName)
    WMQ_MQLONG2HASH (hash, encoding,                      pmqdlh->Encoding)
    WMQ_MQLONG2HASH (hash, coded_char_set_id,             pmqdlh->CodedCharSetId)
    WMQ_MQLONG2HASH (hash, put_appl_type,                 pmqdlh->PutApplType)
    WMQ_MQCHARS2HASH(hash, put_appl_name,                 pmqdlh->PutApplName)
    WMQ_MQCHARS2HASH(hash, put_date,                      pmqdlh->PutDate)
    WMQ_MQCHARS2HASH(hash, put_time,                      pmqdlh->PutTime)
}

static int Message_to_mqdlh_each (VALUE key, VALUE value, MQDLH* pmqdlh)
{
    VALUE str;
    size_t size;
    size_t length; 
    VALUE  val;
    ID     id = rb_to_id(key);
    
    if(id == ID_reason)                { WMQ_STR2MQLONG  (value,pmqdlh->Reason) }
    else if(id == ID_dest_q_name)           { WMQ_STR2MQCHARS (value,pmqdlh->DestQName) }
    else if(id == ID_dest_q_mgr_name)       { WMQ_STR2MQCHARS (value,pmqdlh->DestQMgrName) }
    else if(id == ID_encoding)              { WMQ_STR2MQLONG  (value,pmqdlh->Encoding) }
    else if(id == ID_coded_char_set_id)     { WMQ_STR2MQLONG  (value,pmqdlh->CodedCharSetId) }
    else if(id == ID_put_appl_type)         { WMQ_STR2MQLONG  (value,pmqdlh->PutApplType) }
    else if(id == ID_put_appl_name)         { WMQ_STR2MQCHARS (value,pmqdlh->PutApplName) }
    else if(id == ID_put_date)              { WMQ_STR2MQCHARS (value,pmqdlh->PutDate) }
    else if(id == ID_put_time)              { WMQ_STR2MQCHARS (value,pmqdlh->PutTime) }
    else if(id != ID_header_type)
    {
        val = rb_funcall(key, ID_to_s, 0);
        rb_raise(rb_eArgError, "WMQ::Message#to_mqdlh Unknown symbol :%s supplied", RSTRING_PTR(val));
    }

    return 0;
}

void Message_to_mqdlh(VALUE hash, MQDLH* pmqdlh)
{
    rb_hash_foreach(hash, Message_to_mqdlh_each, (VALUE)pmqdlh);
}

/* --------------------------------------------------------------------------
 *  Convert between MQCIH and Hash
 * --------------------------------------------------------------------------*/
void Message_from_mqcih(VALUE hash, MQCIH* pmqcih)
{
    VALUE  str;
    size_t size;
    size_t length; 
    size_t i;
    char*  pChar;
        
    WMQ_MQLONG2HASH (hash, encoding,                      pmqcih->Encoding)
    WMQ_MQLONG2HASH (hash, coded_char_set_id,             pmqcih->CodedCharSetId)
    WMQ_MQLONG2HASH (hash, flags,                         pmqcih->Flags)
    WMQ_MQLONG2HASH (hash, return_code,                   pmqcih->ReturnCode)
    WMQ_MQLONG2HASH (hash, comp_code,                     pmqcih->CompCode)
    WMQ_MQLONG2HASH (hash, reason,                        pmqcih->Reason)
    WMQ_MQLONG2HASH (hash, uow_control,                   pmqcih->UOWControl)
    WMQ_MQLONG2HASH (hash, get_wait_interval,             pmqcih->GetWaitInterval)
    WMQ_MQLONG2HASH (hash, link_type,                     pmqcih->LinkType)
    WMQ_MQLONG2HASH (hash, output_data_length,            pmqcih->OutputDataLength)
    WMQ_MQLONG2HASH (hash, facility_keep_time,            pmqcih->FacilityKeepTime)
    WMQ_MQLONG2HASH (hash, ads_descriptor,                pmqcih->ADSDescriptor)
    WMQ_MQLONG2HASH (hash, conversational_task,           pmqcih->ConversationalTask)
    WMQ_MQLONG2HASH (hash, task_end_status,               pmqcih->TaskEndStatus)
    WMQ_MQBYTES2HASH(hash, facility,                      pmqcih->Facility)
    WMQ_MQCHARS2HASH(hash, function,                      pmqcih->Function)
    WMQ_MQCHARS2HASH(hash, abend_code,                    pmqcih->AbendCode)
    WMQ_MQCHARS2HASH(hash, authenticator,                 pmqcih->Authenticator)
    WMQ_MQCHARS2HASH(hash, reserved1,                     pmqcih->Reserved1)
    WMQ_MQCHARS2HASH(hash, reply_to_format,               pmqcih->ReplyToFormat)
    WMQ_MQCHARS2HASH(hash, remote_sys_id,                 pmqcih->RemoteSysId)
    WMQ_MQCHARS2HASH(hash, remote_trans_id,               pmqcih->RemoteTransId)
    WMQ_MQCHARS2HASH(hash, transaction_id,                pmqcih->TransactionId)
    WMQ_MQCHARS2HASH(hash, facility_like,                 pmqcih->FacilityLike)
    WMQ_MQCHARS2HASH(hash, attention_id,                  pmqcih->AttentionId)
    WMQ_MQCHARS2HASH(hash, start_code,                    pmqcih->StartCode)
    WMQ_MQCHARS2HASH(hash, cancel_code,                   pmqcih->CancelCode)
    WMQ_MQCHARS2HASH(hash, next_transaction_id,           pmqcih->NextTransactionId)
    WMQ_MQCHARS2HASH(hash, reserved2,                     pmqcih->Reserved2)
    WMQ_MQCHARS2HASH(hash, reserved3,                     pmqcih->Reserved3)
    WMQ_MQLONG2HASH (hash, cursor_position,               pmqcih->CursorPosition)
    WMQ_MQLONG2HASH (hash, error_offset,                  pmqcih->ErrorOffset)
    WMQ_MQLONG2HASH (hash, input_item,                    pmqcih->InputItem)
    WMQ_MQLONG2HASH (hash, reserved4,                     pmqcih->Reserved4)
}

static int Message_to_mqcih_each (VALUE key, VALUE value, MQCIH* pmqcih)
{
    VALUE str;
    size_t size;
    size_t length; 
    VALUE  val;
    ID     id = rb_to_id(key);
    
    if(id == ID_encoding)              { WMQ_STR2MQLONG  (value,pmqcih->Encoding) }
    else if(id == ID_coded_char_set_id)     { WMQ_STR2MQLONG  (value,pmqcih->CodedCharSetId) }
    else if(id == ID_flags)                 { WMQ_STR2MQLONG  (value,pmqcih->Flags) }
    else if(id == ID_return_code)           { WMQ_STR2MQLONG  (value,pmqcih->ReturnCode) }
    else if(id == ID_comp_code)             { WMQ_STR2MQLONG  (value,pmqcih->CompCode) }
    else if(id == ID_reason)                { WMQ_STR2MQLONG  (value,pmqcih->Reason) }
    else if(id == ID_uow_control)           { WMQ_STR2MQLONG  (value,pmqcih->UOWControl) }
    else if(id == ID_get_wait_interval)     { WMQ_STR2MQLONG  (value,pmqcih->GetWaitInterval) }
    else if(id == ID_link_type)             { WMQ_STR2MQLONG  (value,pmqcih->LinkType) }
    else if(id == ID_output_data_length)    { WMQ_STR2MQLONG  (value,pmqcih->OutputDataLength) }
    else if(id == ID_facility_keep_time)    { WMQ_STR2MQLONG  (value,pmqcih->FacilityKeepTime) }
    else if(id == ID_ads_descriptor)        { WMQ_STR2MQLONG  (value,pmqcih->ADSDescriptor) }
    else if(id == ID_conversational_task)   { WMQ_STR2MQLONG  (value,pmqcih->ConversationalTask) }
    else if(id == ID_task_end_status)       { WMQ_STR2MQLONG  (value,pmqcih->TaskEndStatus) }
    else if(id == ID_facility)              { WMQ_STR2MQBYTES (value,pmqcih->Facility) }
    else if(id == ID_function)              { WMQ_STR2MQCHARS (value,pmqcih->Function) }
    else if(id == ID_abend_code)            { WMQ_STR2MQCHARS (value,pmqcih->AbendCode) }
    else if(id == ID_authenticator)         { WMQ_STR2MQCHARS (value,pmqcih->Authenticator) }
    else if(id == ID_reserved1)             { WMQ_STR2MQCHARS (value,pmqcih->Reserved1) }
    else if(id == ID_reply_to_format)       { WMQ_STR2MQCHARS (value,pmqcih->ReplyToFormat) }
    else if(id == ID_remote_sys_id)         { WMQ_STR2MQCHARS (value,pmqcih->RemoteSysId) }
    else if(id == ID_remote_trans_id)       { WMQ_STR2MQCHARS (value,pmqcih->RemoteTransId) }
    else if(id == ID_transaction_id)        { WMQ_STR2MQCHARS (value,pmqcih->TransactionId) }
    else if(id == ID_facility_like)         { WMQ_STR2MQCHARS (value,pmqcih->FacilityLike) }
    else if(id == ID_attention_id)          { WMQ_STR2MQCHARS (value,pmqcih->AttentionId) }
    else if(id == ID_start_code)            { WMQ_STR2MQCHARS (value,pmqcih->StartCode) }
    else if(id == ID_cancel_code)           { WMQ_STR2MQCHARS (value,pmqcih->CancelCode) }
    else if(id == ID_next_transaction_id)   { WMQ_STR2MQCHARS (value,pmqcih->NextTransactionId) }
    else if(id == ID_reserved2)             { WMQ_STR2MQCHARS (value,pmqcih->Reserved2) }
    else if(id == ID_reserved3)             { WMQ_STR2MQCHARS (value,pmqcih->Reserved3) }
    else if(id == ID_cursor_position)       { WMQ_STR2MQLONG  (value,pmqcih->CursorPosition) }
    else if(id == ID_error_offset)          { WMQ_STR2MQLONG  (value,pmqcih->ErrorOffset) }
    else if(id == ID_input_item)            { WMQ_STR2MQLONG  (value,pmqcih->InputItem) }
    else if(id == ID_reserved4)             { WMQ_STR2MQLONG  (value,pmqcih->Reserved4) }
    else if(id != ID_header_type)
    {
        val = rb_funcall(key, ID_to_s, 0);
        rb_raise(rb_eArgError, "WMQ::Message#to_mqcih Unknown symbol :%s supplied", RSTRING_PTR(val));
    }

    return 0;
}

void Message_to_mqcih(VALUE hash, MQCIH* pmqcih)
{
    rb_hash_foreach(hash, Message_to_mqcih_each, (VALUE)pmqcih);
}

/* --------------------------------------------------------------------------
 *  Convert between MQDH and Hash
 * --------------------------------------------------------------------------*/
void Message_from_mqdh(VALUE hash, MQDH* pmqdh)
{
    VALUE  str;
    size_t size;
    size_t length; 
    size_t i;
    char*  pChar;
        
    WMQ_MQLONG2HASH (hash, encoding,                      pmqdh->Encoding)
    WMQ_MQLONG2HASH (hash, coded_char_set_id,             pmqdh->CodedCharSetId)
    WMQ_MQLONG2HASH (hash, flags,                         pmqdh->Flags)
    WMQ_MQLONG2HASH (hash, put_msg_rec_fields,            pmqdh->PutMsgRecFields)
    WMQ_MQLONG2HASH (hash, recs_present,                  pmqdh->RecsPresent)
    WMQ_MQLONG2HASH (hash, object_rec_offset,             pmqdh->ObjectRecOffset)
    WMQ_MQLONG2HASH (hash, put_msg_rec_offset,            pmqdh->PutMsgRecOffset)
}

static int Message_to_mqdh_each (VALUE key, VALUE value, MQDH* pmqdh)
{
    VALUE str;
    size_t size;
    size_t length; 
    VALUE  val;
    ID     id = rb_to_id(key);
    
    if(id == ID_encoding)              { WMQ_STR2MQLONG  (value,pmqdh->Encoding) }
    else if(id == ID_coded_char_set_id)     { WMQ_STR2MQLONG  (value,pmqdh->CodedCharSetId) }
    else if(id == ID_flags)                 { WMQ_STR2MQLONG  (value,pmqdh->Flags) }
    else if(id == ID_put_msg_rec_fields)    { WMQ_STR2MQLONG  (value,pmqdh->PutMsgRecFields) }
    else if(id == ID_recs_present)          { WMQ_STR2MQLONG  (value,pmqdh->RecsPresent) }
    else if(id == ID_object_rec_offset)     { WMQ_STR2MQLONG  (value,pmqdh->ObjectRecOffset) }
    else if(id == ID_put_msg_rec_offset)    { WMQ_STR2MQLONG  (value,pmqdh->PutMsgRecOffset) }
    else if(id != ID_header_type)
    {
        val = rb_funcall(key, ID_to_s, 0);
        rb_raise(rb_eArgError, "WMQ::Message#to_mqdh Unknown symbol :%s supplied", RSTRING_PTR(val));
    }

    return 0;
}

void Message_to_mqdh(VALUE hash, MQDH* pmqdh)
{
    rb_hash_foreach(hash, Message_to_mqdh_each, (VALUE)pmqdh);
}

/* --------------------------------------------------------------------------
 *  Convert between MQIIH and Hash
 * --------------------------------------------------------------------------*/
void Message_from_mqiih(VALUE hash, MQIIH* pmqiih)
{
    VALUE  str;
    size_t size;
    size_t length; 
    size_t i;
    char*  pChar;
        
    WMQ_MQLONG2HASH (hash, encoding,                      pmqiih->Encoding)
    WMQ_MQLONG2HASH (hash, coded_char_set_id,             pmqiih->CodedCharSetId)
    WMQ_MQLONG2HASH (hash, flags,                         pmqiih->Flags)
    WMQ_MQCHARS2HASH(hash, l_term_override,               pmqiih->LTermOverride)
    WMQ_MQCHARS2HASH(hash, mfs_map_name,                  pmqiih->MFSMapName)
    WMQ_MQCHARS2HASH(hash, reply_to_format,               pmqiih->ReplyToFormat)
    WMQ_MQCHARS2HASH(hash, authenticator,                 pmqiih->Authenticator)
    WMQ_MQBYTES2HASH(hash, tran_instance_id,              pmqiih->TranInstanceId)
    WMQ_MQCHAR2HASH (hash, tran_state,                    pmqiih->TranState)
    WMQ_MQCHAR2HASH (hash, commit_mode,                   pmqiih->CommitMode)
    WMQ_MQCHAR2HASH (hash, security_scope,                pmqiih->SecurityScope)
    WMQ_MQCHAR2HASH (hash, reserved,                      pmqiih->Reserved)
}

static int Message_to_mqiih_each (VALUE key, VALUE value, MQIIH* pmqiih)
{
    VALUE str;
    size_t size;
    size_t length; 
    VALUE  val;
    ID     id = rb_to_id(key);
    
    if(id == ID_encoding)              { WMQ_STR2MQLONG  (value,pmqiih->Encoding) }
    else if(id == ID_coded_char_set_id)     { WMQ_STR2MQLONG  (value,pmqiih->CodedCharSetId) }
    else if(id == ID_flags)                 { WMQ_STR2MQLONG  (value,pmqiih->Flags) }
    else if(id == ID_l_term_override)       { WMQ_STR2MQCHARS (value,pmqiih->LTermOverride) }
    else if(id == ID_mfs_map_name)          { WMQ_STR2MQCHARS (value,pmqiih->MFSMapName) }
    else if(id == ID_reply_to_format)       { WMQ_STR2MQCHARS (value,pmqiih->ReplyToFormat) }
    else if(id == ID_authenticator)         { WMQ_STR2MQCHARS (value,pmqiih->Authenticator) }
    else if(id == ID_tran_instance_id)      { WMQ_STR2MQBYTES (value,pmqiih->TranInstanceId) }
    else if(id == ID_tran_state)            { WMQ_STR2MQCHAR  (value,pmqiih->TranState) }
    else if(id == ID_commit_mode)           { WMQ_STR2MQCHAR  (value,pmqiih->CommitMode) }
    else if(id == ID_security_scope)        { WMQ_STR2MQCHAR  (value,pmqiih->SecurityScope) }
    else if(id == ID_reserved)              { WMQ_STR2MQCHAR  (value,pmqiih->Reserved) }
    else if(id != ID_header_type)
    {
        val = rb_funcall(key, ID_to_s, 0);
        rb_raise(rb_eArgError, "WMQ::Message#to_mqiih Unknown symbol :%s supplied", RSTRING_PTR(val));
    }

    return 0;
}

void Message_to_mqiih(VALUE hash, MQIIH* pmqiih)
{
    rb_hash_foreach(hash, Message_to_mqiih_each, (VALUE)pmqiih);
}

/* --------------------------------------------------------------------------
 *  Convert between MQRMH and Hash
 * --------------------------------------------------------------------------*/
void Message_from_mqrmh(VALUE hash, MQRMH* pmqrmh)
{
    VALUE  str;
    size_t size;
    size_t length; 
    size_t i;
    char*  pChar;
        
    WMQ_MQLONG2HASH (hash, encoding,                      pmqrmh->Encoding)
    WMQ_MQLONG2HASH (hash, coded_char_set_id,             pmqrmh->CodedCharSetId)
    WMQ_MQLONG2HASH (hash, flags,                         pmqrmh->Flags)
    WMQ_MQCHARS2HASH(hash, object_type,                   pmqrmh->ObjectType)
    WMQ_MQBYTES2HASH(hash, object_instance_id,            pmqrmh->ObjectInstanceId)
    WMQ_MQLONG2HASH (hash, src_env_length,                pmqrmh->SrcEnvLength)
    WMQ_MQLONG2HASH (hash, src_env_offset,                pmqrmh->SrcEnvOffset)
    WMQ_MQLONG2HASH (hash, src_name_length,               pmqrmh->SrcNameLength)
    WMQ_MQLONG2HASH (hash, src_name_offset,               pmqrmh->SrcNameOffset)
    WMQ_MQLONG2HASH (hash, dest_env_length,               pmqrmh->DestEnvLength)
    WMQ_MQLONG2HASH (hash, dest_env_offset,               pmqrmh->DestEnvOffset)
    WMQ_MQLONG2HASH (hash, dest_name_length,              pmqrmh->DestNameLength)
    WMQ_MQLONG2HASH (hash, dest_name_offset,              pmqrmh->DestNameOffset)
    WMQ_MQLONG2HASH (hash, data_logical_length,           pmqrmh->DataLogicalLength)
    WMQ_MQLONG2HASH (hash, data_logical_offset,           pmqrmh->DataLogicalOffset)
    WMQ_MQLONG2HASH (hash, data_logical_offset2,          pmqrmh->DataLogicalOffset2)
}

static int Message_to_mqrmh_each (VALUE key, VALUE value, MQRMH* pmqrmh)
{
    VALUE str;
    size_t size;
    size_t length; 
    VALUE  val;
    ID     id = rb_to_id(key);
    
    if(id == ID_encoding)              { WMQ_STR2MQLONG  (value,pmqrmh->Encoding) }
    else if(id == ID_coded_char_set_id)     { WMQ_STR2MQLONG  (value,pmqrmh->CodedCharSetId) }
    else if(id == ID_flags)                 { WMQ_STR2MQLONG  (value,pmqrmh->Flags) }
    else if(id == ID_object_type)           { WMQ_STR2MQCHARS (value,pmqrmh->ObjectType) }
    else if(id == ID_object_instance_id)    { WMQ_STR2MQBYTES (value,pmqrmh->ObjectInstanceId) }
    else if(id == ID_src_env_length)        { WMQ_STR2MQLONG  (value,pmqrmh->SrcEnvLength) }
    else if(id == ID_src_env_offset)        { WMQ_STR2MQLONG  (value,pmqrmh->SrcEnvOffset) }
    else if(id == ID_src_name_length)       { WMQ_STR2MQLONG  (value,pmqrmh->SrcNameLength) }
    else if(id == ID_src_name_offset)       { WMQ_STR2MQLONG  (value,pmqrmh->SrcNameOffset) }
    else if(id == ID_dest_env_length)       { WMQ_STR2MQLONG  (value,pmqrmh->DestEnvLength) }
    else if(id == ID_dest_env_offset)       { WMQ_STR2MQLONG  (value,pmqrmh->DestEnvOffset) }
    else if(id == ID_dest_name_length)      { WMQ_STR2MQLONG  (value,pmqrmh->DestNameLength) }
    else if(id == ID_dest_name_offset)      { WMQ_STR2MQLONG  (value,pmqrmh->DestNameOffset) }
    else if(id == ID_data_logical_length)   { WMQ_STR2MQLONG  (value,pmqrmh->DataLogicalLength) }
    else if(id == ID_data_logical_offset)   { WMQ_STR2MQLONG  (value,pmqrmh->DataLogicalOffset) }
    else if(id == ID_data_logical_offset2)  { WMQ_STR2MQLONG  (value,pmqrmh->DataLogicalOffset2) }
    else if(id != ID_header_type)
    {
        val = rb_funcall(key, ID_to_s, 0);
        rb_raise(rb_eArgError, "WMQ::Message#to_mqrmh Unknown symbol :%s supplied", RSTRING_PTR(val));
    }

    return 0;
}

void Message_to_mqrmh(VALUE hash, MQRMH* pmqrmh)
{
    rb_hash_foreach(hash, Message_to_mqrmh_each, (VALUE)pmqrmh);
}

/* --------------------------------------------------------------------------
 *  Convert between MQTM and Hash
 * --------------------------------------------------------------------------*/
void Message_from_mqtm(VALUE hash, MQTM* pmqtm)
{
    VALUE  str;
    size_t size;
    size_t length; 
    size_t i;
    char*  pChar;
        
    WMQ_MQCHARS2HASH(hash, q_name,                        pmqtm->QName)
    WMQ_MQCHARS2HASH(hash, process_name,                  pmqtm->ProcessName)
    WMQ_MQCHARS2HASH(hash, trigger_data,                  pmqtm->TriggerData)
    WMQ_MQLONG2HASH (hash, appl_type,                     pmqtm->ApplType)
    WMQ_MQCHARS2HASH(hash, appl_id,                       pmqtm->ApplId)
    WMQ_MQCHARS2HASH(hash, env_data,                      pmqtm->EnvData)
    WMQ_MQCHARS2HASH(hash, user_data,                     pmqtm->UserData)
}

static int Message_to_mqtm_each (VALUE key, VALUE value, MQTM* pmqtm)
{
    VALUE str;
    size_t size;
    size_t length; 
    VALUE  val;
    ID     id = rb_to_id(key);
    
    if(id == ID_q_name)                { WMQ_STR2MQCHARS (value,pmqtm->QName) }
    else if(id == ID_process_name)          { WMQ_STR2MQCHARS (value,pmqtm->ProcessName) }
    else if(id == ID_trigger_data)          { WMQ_STR2MQCHARS (value,pmqtm->TriggerData) }
    else if(id == ID_appl_type)             { WMQ_STR2MQLONG  (value,pmqtm->ApplType) }
    else if(id == ID_appl_id)               { WMQ_STR2MQCHARS (value,pmqtm->ApplId) }
    else if(id == ID_env_data)              { WMQ_STR2MQCHARS (value,pmqtm->EnvData) }
    else if(id == ID_user_data)             { WMQ_STR2MQCHARS (value,pmqtm->UserData) }
    else if(id != ID_header_type)
    {
        val = rb_funcall(key, ID_to_s, 0);
        rb_raise(rb_eArgError, "WMQ::Message#to_mqtm Unknown symbol :%s supplied", RSTRING_PTR(val));
    }

    return 0;
}

void Message_to_mqtm(VALUE hash, MQTM* pmqtm)
{
    rb_hash_foreach(hash, Message_to_mqtm_each, (VALUE)pmqtm);
}

/* --------------------------------------------------------------------------
 *  Convert between MQTMC2 and Hash
 * --------------------------------------------------------------------------*/
void Message_from_mqtmc2(VALUE hash, MQTMC2* pmqtmc2)
{
    VALUE  str;
    size_t size;
    size_t length; 
    size_t i;
    char*  pChar;
        
    WMQ_MQCHARS2HASH(hash, q_name,                        pmqtmc2->QName)
    WMQ_MQCHARS2HASH(hash, process_name,                  pmqtmc2->ProcessName)
    WMQ_MQCHARS2HASH(hash, trigger_data,                  pmqtmc2->TriggerData)
    WMQ_MQCHARS2HASH(hash, appl_type,                     pmqtmc2->ApplType)
    WMQ_MQCHARS2HASH(hash, appl_id,                       pmqtmc2->ApplId)
    WMQ_MQCHARS2HASH(hash, env_data,                      pmqtmc2->EnvData)
    WMQ_MQCHARS2HASH(hash, user_data,                     pmqtmc2->UserData)
    WMQ_MQCHARS2HASH(hash, q_mgr_name,                    pmqtmc2->QMgrName)
}

static int Message_to_mqtmc2_each (VALUE key, VALUE value, MQTMC2* pmqtmc2)
{
    VALUE str;
    size_t size;
    size_t length; 
    VALUE  val;
    ID     id = rb_to_id(key);
    
    if(id == ID_q_name)                { WMQ_STR2MQCHARS (value,pmqtmc2->QName) }
    else if(id == ID_process_name)          { WMQ_STR2MQCHARS (value,pmqtmc2->ProcessName) }
    else if(id == ID_trigger_data)          { WMQ_STR2MQCHARS (value,pmqtmc2->TriggerData) }
    else if(id == ID_appl_type)             { WMQ_STR2MQCHARS (value,pmqtmc2->ApplType) }
    else if(id == ID_appl_id)               { WMQ_STR2MQCHARS (value,pmqtmc2->ApplId) }
    else if(id == ID_env_data)              { WMQ_STR2MQCHARS (value,pmqtmc2->EnvData) }
    else if(id == ID_user_data)             { WMQ_STR2MQCHARS (value,pmqtmc2->UserData) }
    else if(id == ID_q_mgr_name)            { WMQ_STR2MQCHARS (value,pmqtmc2->QMgrName) }
    else
    {
        val = rb_funcall(key, ID_to_s, 0);
        rb_raise(rb_eArgError, "WMQ::Message#to_mqtmc2 Unknown symbol :%s supplied", RSTRING_PTR(val));
    }

    return 0;
}

void Message_to_mqtmc2(VALUE hash, MQTMC2* pmqtmc2)
{
    rb_hash_foreach(hash, Message_to_mqtmc2_each, (VALUE)pmqtmc2);
}

/* --------------------------------------------------------------------------
 *  Convert between MQWIH and Hash
 * --------------------------------------------------------------------------*/
void Message_from_mqwih(VALUE hash, MQWIH* pmqwih)
{
    VALUE  str;
    size_t size;
    size_t length; 
    size_t i;
    char*  pChar;
        
    WMQ_MQLONG2HASH (hash, encoding,                      pmqwih->Encoding)
    WMQ_MQLONG2HASH (hash, coded_char_set_id,             pmqwih->CodedCharSetId)
    WMQ_MQLONG2HASH (hash, flags,                         pmqwih->Flags)
    WMQ_MQCHARS2HASH(hash, service_name,                  pmqwih->ServiceName)
    WMQ_MQCHARS2HASH(hash, service_step,                  pmqwih->ServiceStep)
    WMQ_MQBYTES2HASH(hash, msg_token,                     pmqwih->MsgToken)
    WMQ_MQCHARS2HASH(hash, reserved,                      pmqwih->Reserved)
}

static int Message_to_mqwih_each (VALUE key, VALUE value, MQWIH* pmqwih)
{
    VALUE str;
    size_t size;
    size_t length; 
    VALUE  val;
    ID     id = rb_to_id(key);
    
    if(id == ID_encoding)              { WMQ_STR2MQLONG  (value,pmqwih->Encoding) }
    else if(id == ID_coded_char_set_id)     { WMQ_STR2MQLONG  (value,pmqwih->CodedCharSetId) }
    else if(id == ID_flags)                 { WMQ_STR2MQLONG  (value,pmqwih->Flags) }
    else if(id == ID_service_name)          { WMQ_STR2MQCHARS (value,pmqwih->ServiceName) }
    else if(id == ID_service_step)          { WMQ_STR2MQCHARS (value,pmqwih->ServiceStep) }
    else if(id == ID_msg_token)             { WMQ_STR2MQBYTES (value,pmqwih->MsgToken) }
    else if(id == ID_reserved)              { WMQ_STR2MQCHARS (value,pmqwih->Reserved) }
    else if(id != ID_header_type)
    {
        val = rb_funcall(key, ID_to_s, 0);
        rb_raise(rb_eArgError, "WMQ::Message#to_mqwih Unknown symbol :%s supplied", RSTRING_PTR(val));
    }

    return 0;
}

void Message_to_mqwih(VALUE hash, MQWIH* pmqwih)
{
    rb_hash_foreach(hash, Message_to_mqwih_each, (VALUE)pmqwih);
}

/* --------------------------------------------------------------------------
 *  Convert between MQXQH and Hash
 * --------------------------------------------------------------------------*/
void Message_from_mqxqh(VALUE hash, MQXQH* pmqxqh)
{
    VALUE  str;
    size_t size;
    size_t length; 
    size_t i;
    char*  pChar;
        
    WMQ_MQCHARS2HASH(hash, remote_q_name,                 pmqxqh->RemoteQName)
    WMQ_MQCHARS2HASH(hash, remote_q_mgr_name,             pmqxqh->RemoteQMgrName)
    Message_from_mqmd1(hash, &pmqxqh->MsgDesc);
}

static int Message_to_mqxqh_each (VALUE key, VALUE value, MQXQH* pmqxqh)
{
    VALUE str;
    size_t size;
    size_t length; 
    VALUE  val;
    ID     id = rb_to_id(key);
    
    if(id == ID_remote_q_name)         { WMQ_STR2MQCHARS (value,pmqxqh->RemoteQName) }
    else if(id == ID_remote_q_mgr_name)     { WMQ_STR2MQCHARS (value,pmqxqh->RemoteQMgrName) }
    else if(id != ID_header_type) {
      Message_to_mqmd1_each(key, value, &pmqxqh->MsgDesc); 
   }
    return 0;
}

void Message_to_mqxqh(VALUE hash, MQXQH* pmqxqh)
{
    rb_hash_foreach(hash, Message_to_mqxqh_each, (VALUE)pmqxqh);
}


/* --------------------------------------------------------------------------
 *  Extract message data and headers
 * --------------------------------------------------------------------------*/
void Message_deblock(VALUE self, PMQMD pmqmd, PMQBYTE p_buffer, MQLONG total_length, MQLONG trace_level)
{
    PMQCHAR p_format   = pmqmd->Format;               /* Start with format in MQMD     */
    PMQBYTE p_data     = p_buffer;                    /* Pointer to start of data      */
    MQLONG  data_length= total_length;                /* length of data portion        */
    VALUE   headers    = rb_ary_new();
    VALUE   descriptor = rb_hash_new();
    MQLONG  size       = 0;

    while (p_format)
    {
        /* MQRFH2: rf_header_2 */
        if(strncmp(p_format, MQFMT_RF_HEADER_2, MQ_FORMAT_LENGTH) == 0)
        {
            VALUE hash = rb_hash_new();
            PMQRFH2 p_header = (PMQRFH2)p_data;
            
            if(trace_level>2)
                printf("WMQ::Message#deblock Found rf_header_2\n");
                
            if(memcmp(p_header->StrucId, MQRFH_STRUC_ID, sizeof(p_header->StrucId)) != 0)
            {
                if(trace_level>1)
                    printf("WMQ::Message#deblock MQFMT_RF_HEADER_2 received, but message does not contain MQRFH2\n");
                break;    /* Bad Message received, do not deblock headers */
            }
            else
            {
                Message_from_mqrfh2(hash, p_header);
                rb_hash_aset(hash, ID2SYM(ID_header_type), ID2SYM(ID_rf_header_2));
                rb_ary_push(headers, hash);
                size        = Message_deblock_rf_header_2 (hash, p_data, data_length);
                if (!size) break; /* Poison Message */
                p_data      += size;
                data_length -= size;
                p_format    = p_header->Format;
            }
        }
        else
        /* MQRFH: rf_header */
        if(strncmp(p_format, MQFMT_RF_HEADER, MQ_FORMAT_LENGTH) == 0)
        {
            VALUE hash = rb_hash_new();
            PMQRFH p_header = (PMQRFH)p_data;
            
            if(trace_level>2)
                printf("WMQ::Message#deblock Found rf_header\n");
                
            if(memcmp(p_header->StrucId, MQRFH_STRUC_ID, sizeof(p_header->StrucId)) != 0)
            {
                if(trace_level>1)
                    printf("WMQ::Message#deblock MQFMT_RF_HEADER received, but message does not contain MQRFH\n");
                break;    /* Bad Message received, do not deblock headers */
            }
            else
            {
                Message_from_mqrfh(hash, p_header);
                rb_hash_aset(hash, ID2SYM(ID_header_type), ID2SYM(ID_rf_header));
                rb_ary_push(headers, hash);
                size        = Message_deblock_rf_header (hash, p_data, data_length);
                if (!size) break; /* Poison Message */
                p_data      += size;
                data_length -= size;
                p_format    = p_header->Format;
            }
        }
        else
        /* MQDLH: dead_letter_header */
        if(strncmp(p_format, MQFMT_DEAD_LETTER_HEADER, MQ_FORMAT_LENGTH) == 0)
        {
            VALUE hash = rb_hash_new();
            PMQDLH p_header = (PMQDLH)p_data;
            
            if(trace_level>2)
                printf("WMQ::Message#deblock Found dead_letter_header\n");
                
            if(memcmp(p_header->StrucId, MQDLH_STRUC_ID, sizeof(p_header->StrucId)) != 0)
            {
                if(trace_level>1)
                    printf("WMQ::Message#deblock MQFMT_DEAD_LETTER_HEADER received, but message does not contain MQDLH\n");
                break;    /* Bad Message received, do not deblock headers */
            }
            else
            {
                Message_from_mqdlh(hash, p_header);
                rb_hash_aset(hash, ID2SYM(ID_header_type), ID2SYM(ID_dead_letter_header));
                rb_ary_push(headers, hash);
                size        = sizeof(MQDLH);
                p_data      += size;
                data_length -= size;
                p_format    = p_header->Format;
            }
        }
        else
        /* MQCIH: cics */
        if(strncmp(p_format, MQFMT_CICS, MQ_FORMAT_LENGTH) == 0)
        {
            VALUE hash = rb_hash_new();
            PMQCIH p_header = (PMQCIH)p_data;
            
            if(trace_level>2)
                printf("WMQ::Message#deblock Found cics\n");
                
            if(memcmp(p_header->StrucId, MQCIH_STRUC_ID, sizeof(p_header->StrucId)) != 0)
            {
                if(trace_level>1)
                    printf("WMQ::Message#deblock MQFMT_CICS received, but message does not contain MQCIH\n");
                break;    /* Bad Message received, do not deblock headers */
            }
            else
            {
                Message_from_mqcih(hash, p_header);
                rb_hash_aset(hash, ID2SYM(ID_header_type), ID2SYM(ID_cics));
                rb_ary_push(headers, hash);
                size        = p_header->StrucLength;
                p_data      += size;
                data_length -= size;
                p_format    = p_header->Format;
            }
        }
        else
        /* MQDH: dist_header */
        if(strncmp(p_format, MQFMT_DIST_HEADER, MQ_FORMAT_LENGTH) == 0)
        {
            VALUE hash = rb_hash_new();
            PMQDH p_header = (PMQDH)p_data;
            
            if(trace_level>2)
                printf("WMQ::Message#deblock Found dist_header\n");
                
            if(memcmp(p_header->StrucId, MQDH_STRUC_ID, sizeof(p_header->StrucId)) != 0)
            {
                if(trace_level>1)
                    printf("WMQ::Message#deblock MQFMT_DIST_HEADER received, but message does not contain MQDH\n");
                break;    /* Bad Message received, do not deblock headers */
            }
            else
            {
                Message_from_mqdh(hash, p_header);
                rb_hash_aset(hash, ID2SYM(ID_header_type), ID2SYM(ID_dist_header));
                rb_ary_push(headers, hash);
                size        = p_header->StrucLength;
                p_data      += size;
                data_length -= size;
                p_format    = p_header->Format;
            }
        }
        else
        /* MQIIH: ims */
        if(strncmp(p_format, MQFMT_IMS, MQ_FORMAT_LENGTH) == 0)
        {
            VALUE hash = rb_hash_new();
            PMQIIH p_header = (PMQIIH)p_data;
            
            if(trace_level>2)
                printf("WMQ::Message#deblock Found ims\n");
                
            if(memcmp(p_header->StrucId, MQIIH_STRUC_ID, sizeof(p_header->StrucId)) != 0)
            {
                if(trace_level>1)
                    printf("WMQ::Message#deblock MQFMT_IMS received, but message does not contain MQIIH\n");
                break;    /* Bad Message received, do not deblock headers */
            }
            else
            {
                Message_from_mqiih(hash, p_header);
                rb_hash_aset(hash, ID2SYM(ID_header_type), ID2SYM(ID_ims));
                rb_ary_push(headers, hash);
                size        = p_header->StrucLength;
                p_data      += size;
                data_length -= size;
                p_format    = p_header->Format;
            }
        }
        else
        /* MQRMH: ref_msg_header */
        if(strncmp(p_format, MQFMT_REF_MSG_HEADER, MQ_FORMAT_LENGTH) == 0)
        {
            VALUE hash = rb_hash_new();
            PMQRMH p_header = (PMQRMH)p_data;
            
            if(trace_level>2)
                printf("WMQ::Message#deblock Found ref_msg_header\n");
                
            if(memcmp(p_header->StrucId, MQRMH_STRUC_ID, sizeof(p_header->StrucId)) != 0)
            {
                if(trace_level>1)
                    printf("WMQ::Message#deblock MQFMT_REF_MSG_HEADER received, but message does not contain MQRMH\n");
                break;    /* Bad Message received, do not deblock headers */
            }
            else
            {
                Message_from_mqrmh(hash, p_header);
                rb_hash_aset(hash, ID2SYM(ID_header_type), ID2SYM(ID_ref_msg_header));
                rb_ary_push(headers, hash);
                size        = p_header->StrucLength;
                p_data      += size;
                data_length -= size;
                p_format    = p_header->Format;
            }
        }
        else
        /* MQTM: trigger */
        if(strncmp(p_format, MQFMT_TRIGGER, MQ_FORMAT_LENGTH) == 0)
        {
            VALUE hash = rb_hash_new();
            PMQTM p_header = (PMQTM)p_data;
            
            if(trace_level>2)
                printf("WMQ::Message#deblock Found trigger\n");
                
            if(memcmp(p_header->StrucId, MQTM_STRUC_ID, sizeof(p_header->StrucId)) != 0)
            {
                if(trace_level>1)
                    printf("WMQ::Message#deblock MQFMT_TRIGGER received, but message does not contain MQTM\n");
                break;    /* Bad Message received, do not deblock headers */
            }
            else
            {
                Message_from_mqtm(hash, p_header);
                rb_hash_aset(hash, ID2SYM(ID_header_type), ID2SYM(ID_trigger));
                rb_ary_push(headers, hash);
                size        = sizeof(MQTM);
                p_data      += size;
                data_length -= size;
                break;
            }
        }
        else
        /* MQWIH: work_info_header */
        if(strncmp(p_format, MQFMT_WORK_INFO_HEADER, MQ_FORMAT_LENGTH) == 0)
        {
            VALUE hash = rb_hash_new();
            PMQWIH p_header = (PMQWIH)p_data;
            
            if(trace_level>2)
                printf("WMQ::Message#deblock Found work_info_header\n");
                
            if(memcmp(p_header->StrucId, MQWIH_STRUC_ID, sizeof(p_header->StrucId)) != 0)
            {
                if(trace_level>1)
                    printf("WMQ::Message#deblock MQFMT_WORK_INFO_HEADER received, but message does not contain MQWIH\n");
                break;    /* Bad Message received, do not deblock headers */
            }
            else
            {
                Message_from_mqwih(hash, p_header);
                rb_hash_aset(hash, ID2SYM(ID_header_type), ID2SYM(ID_work_info_header));
                rb_ary_push(headers, hash);
                size        = p_header->StrucLength;
                p_data      += size;
                data_length -= size;
                p_format    = p_header->Format;
            }
        }
        else
        /* MQXQH: xmit_q_header */
        if(strncmp(p_format, MQFMT_XMIT_Q_HEADER, MQ_FORMAT_LENGTH) == 0)
        {
            VALUE hash = rb_hash_new();
            PMQXQH p_header = (PMQXQH)p_data;
            
            if(trace_level>2)
                printf("WMQ::Message#deblock Found xmit_q_header\n");
                
            if(memcmp(p_header->StrucId, MQXQH_STRUC_ID, sizeof(p_header->StrucId)) != 0)
            {
                if(trace_level>1)
                    printf("WMQ::Message#deblock MQFMT_XMIT_Q_HEADER received, but message does not contain MQXQH\n");
                break;    /* Bad Message received, do not deblock headers */
            }
            else
            {
                Message_from_mqxqh(hash, p_header);
                rb_hash_aset(hash, ID2SYM(ID_header_type), ID2SYM(ID_xmit_q_header));
                rb_ary_push(headers, hash);
                size        = sizeof(MQXQH);
                p_data      += size;
                data_length -= size;
                p_format    = p_header->MsgDesc.Format;
            }
        }
        else
        {
            break;
        }
    }
    /* Copy the last recognised header found to the Descriptor */
    if(p_format && p_format != pmqmd->Format)
    {
        strncpy(pmqmd->Format, p_format, MQ_FORMAT_LENGTH);
    }
    
    Message_from_mqmd(descriptor, pmqmd);
    rb_funcall(self, ID_descriptor_set, 1, descriptor);
    rb_funcall(self, ID_headers_set, 1, headers);
    rb_funcall(self, ID_data_set, 1, rb_str_new(p_data, data_length));
}

void Message_build_set_format(ID header_type, PMQBYTE p_format)
{
    if(header_type == ID_rf_header_2) { memcpy(p_format, MQFMT_RF_HEADER_2, MQ_FORMAT_LENGTH); return;}
    if(header_type == ID_rf_header) { memcpy(p_format, MQFMT_RF_HEADER, MQ_FORMAT_LENGTH); return;}
    if(header_type == ID_dead_letter_header) { memcpy(p_format, MQFMT_DEAD_LETTER_HEADER, MQ_FORMAT_LENGTH); return;}
    if(header_type == ID_cics) { memcpy(p_format, MQFMT_CICS, MQ_FORMAT_LENGTH); return;}
    if(header_type == ID_dist_header) { memcpy(p_format, MQFMT_DIST_HEADER, MQ_FORMAT_LENGTH); return;}
    if(header_type == ID_ims) { memcpy(p_format, MQFMT_IMS, MQ_FORMAT_LENGTH); return;}
    if(header_type == ID_ref_msg_header) { memcpy(p_format, MQFMT_REF_MSG_HEADER, MQ_FORMAT_LENGTH); return;}
    if(header_type == ID_trigger) { memcpy(p_format, MQFMT_TRIGGER, MQ_FORMAT_LENGTH); return;}
    if(header_type == ID_work_info_header) { memcpy(p_format, MQFMT_WORK_INFO_HEADER, MQ_FORMAT_LENGTH); return;}
    if(header_type == ID_xmit_q_header) { memcpy(p_format, MQFMT_XMIT_Q_HEADER, MQ_FORMAT_LENGTH); return;}

    rb_raise(rb_eArgError, "Invalid/Unknown header_type supplied in WMQ::Message#headers array");
}

/* --------------------------------------------------------------------------
 *  Build message headers
 * --------------------------------------------------------------------------*/
int Message_build_header (VALUE hash, struct Message_build_header_arg* parg)
{
    VALUE   val = rb_hash_aref(hash, ID2SYM(ID_header_type));
    PMQBYTE p_data = 0;

    if (!NIL_P(val) && (TYPE(val) == T_SYMBOL))
    {
        ID header_id = rb_to_id(val);
        if (header_id == ID_rf_header_2)  /* Build MQRFH2 */
        { 
            Message_build_rf_header_2 (hash, parg);
        }
        else
        if (header_id == ID_rf_header)  /* Build MQRFH */
        { 
            Message_build_rf_header (hash, parg);
        }
        else
        if (header_id == ID_dead_letter_header)  /* Build MQDLH */
        { 
            static MQDLH MQDLH_DEF = {MQDLH_DEFAULT};
            MQDLH_DEF.CodedCharSetId = MQCCSI_INHERIT;

            if(parg->trace_level>2)
                printf ("WMQ::Message#build_header Found dead_letter_header\n");
                
            p_data = Message_autogrow_data_buffer(parg, sizeof(MQDLH));

            memcpy(p_data, &MQDLH_DEF, sizeof(MQDLH));
            Message_to_mqdlh(hash, (PMQDLH)p_data);

            if(parg->next_header_id)
            {
                Message_build_set_format(parg->next_header_id, ((PMQDLH)p_data)->Format);
            }
            else
            {
                memcpy(((PMQDLH)p_data)->Format, parg->data_format, MQ_FORMAT_LENGTH);
            }

            *(parg->p_data_offset) += sizeof(MQDLH);

            if(parg->trace_level>2)
                printf ("WMQ::Message#build_header data offset:%ld\n", (long)(*(parg->p_data_offset)));
        }
        else
        if (header_id == ID_cics)  /* Build MQCIH */
        { 
            static MQCIH MQCIH_DEF = {MQCIH_DEFAULT};
            

            if(parg->trace_level>2)
                printf ("WMQ::Message#build_header Found cics\n");
                
            p_data = Message_autogrow_data_buffer(parg, sizeof(MQCIH));

            memcpy(p_data, &MQCIH_DEF, sizeof(MQCIH));
            Message_to_mqcih(hash, (PMQCIH)p_data);

            if(parg->next_header_id)
            {
                Message_build_set_format(parg->next_header_id, ((PMQCIH)p_data)->Format);
            }
            else
            {
                memcpy(((PMQCIH)p_data)->Format, parg->data_format, MQ_FORMAT_LENGTH);
            }

            *(parg->p_data_offset) += sizeof(MQCIH);

            if(parg->trace_level>2)
                printf ("WMQ::Message#build_header data offset:%ld\n", (long)(*(parg->p_data_offset)));
        }
        else
        if (header_id == ID_dist_header)  /* Build MQDH */
        { 
            static MQDH MQDH_DEF = {MQDH_DEFAULT};
            

            if(parg->trace_level>2)
                printf ("WMQ::Message#build_header Found dist_header\n");
                
            p_data = Message_autogrow_data_buffer(parg, sizeof(MQDH));

            memcpy(p_data, &MQDH_DEF, sizeof(MQDH));
            Message_to_mqdh(hash, (PMQDH)p_data);

            if(parg->next_header_id)
            {
                Message_build_set_format(parg->next_header_id, ((PMQDH)p_data)->Format);
            }
            else
            {
                memcpy(((PMQDH)p_data)->Format, parg->data_format, MQ_FORMAT_LENGTH);
            }

            *(parg->p_data_offset) += sizeof(MQDH);

            if(parg->trace_level>2)
                printf ("WMQ::Message#build_header data offset:%ld\n", (long)(*(parg->p_data_offset)));
        }
        else
        if (header_id == ID_ims)  /* Build MQIIH */
        { 
            static MQIIH MQIIH_DEF = {MQIIH_DEFAULT};
            

            if(parg->trace_level>2)
                printf ("WMQ::Message#build_header Found ims\n");
                
            p_data = Message_autogrow_data_buffer(parg, sizeof(MQIIH));

            memcpy(p_data, &MQIIH_DEF, sizeof(MQIIH));
            Message_to_mqiih(hash, (PMQIIH)p_data);

            if(parg->next_header_id)
            {
                Message_build_set_format(parg->next_header_id, ((PMQIIH)p_data)->Format);
            }
            else
            {
                memcpy(((PMQIIH)p_data)->Format, parg->data_format, MQ_FORMAT_LENGTH);
            }

            *(parg->p_data_offset) += sizeof(MQIIH);

            if(parg->trace_level>2)
                printf ("WMQ::Message#build_header data offset:%ld\n", (long)(*(parg->p_data_offset)));
        }
        else
        if (header_id == ID_ref_msg_header)  /* Build MQRMH */
        { 
            static MQRMH MQRMH_DEF = {MQRMH_DEFAULT};
            

            if(parg->trace_level>2)
                printf ("WMQ::Message#build_header Found ref_msg_header\n");
                
            p_data = Message_autogrow_data_buffer(parg, sizeof(MQRMH));

            memcpy(p_data, &MQRMH_DEF, sizeof(MQRMH));
            Message_to_mqrmh(hash, (PMQRMH)p_data);

            if(parg->next_header_id)
            {
                Message_build_set_format(parg->next_header_id, ((PMQRMH)p_data)->Format);
            }
            else
            {
                memcpy(((PMQRMH)p_data)->Format, parg->data_format, MQ_FORMAT_LENGTH);
            }

            *(parg->p_data_offset) += sizeof(MQRMH);

            if(parg->trace_level>2)
                printf ("WMQ::Message#build_header data offset:%ld\n", (long)(*(parg->p_data_offset)));
        }
        else
        if (header_id == ID_trigger)  /* Build MQTM */
        { 
            static MQTM MQTM_DEF = {MQTM_DEFAULT};
            

            if(parg->trace_level>2)
                printf ("WMQ::Message#build_header Found trigger\n");
                
            p_data = Message_autogrow_data_buffer(parg, sizeof(MQTM));

            memcpy(p_data, &MQTM_DEF, sizeof(MQTM));
            Message_to_mqtm(hash, (PMQTM)p_data);

            *(parg->p_data_offset) += sizeof(MQTM);

            if(parg->trace_level>2)
                printf ("WMQ::Message#build_header data offset:%ld\n", (long)(*(parg->p_data_offset)));
        }
        else
        if (header_id == ID_work_info_header)  /* Build MQWIH */
        { 
            static MQWIH MQWIH_DEF = {MQWIH_DEFAULT};
            

            if(parg->trace_level>2)
                printf ("WMQ::Message#build_header Found work_info_header\n");
                
            p_data = Message_autogrow_data_buffer(parg, sizeof(MQWIH));

            memcpy(p_data, &MQWIH_DEF, sizeof(MQWIH));
            Message_to_mqwih(hash, (PMQWIH)p_data);

            if(parg->next_header_id)
            {
                Message_build_set_format(parg->next_header_id, ((PMQWIH)p_data)->Format);
            }
            else
            {
                memcpy(((PMQWIH)p_data)->Format, parg->data_format, MQ_FORMAT_LENGTH);
            }

            *(parg->p_data_offset) += sizeof(MQWIH);

            if(parg->trace_level>2)
                printf ("WMQ::Message#build_header data offset:%ld\n", (long)(*(parg->p_data_offset)));
        }
        else
        if (header_id == ID_xmit_q_header)  /* Build MQXQH */
        { 
            static MQXQH MQXQH_DEF = {MQXQH_DEFAULT};
            

            if(parg->trace_level>2)
                printf ("WMQ::Message#build_header Found xmit_q_header\n");
                
            p_data = Message_autogrow_data_buffer(parg, sizeof(MQXQH));

            memcpy(p_data, &MQXQH_DEF, sizeof(MQXQH));
            Message_to_mqxqh(hash, (PMQXQH)p_data);

            if(parg->next_header_id)
            {
                Message_build_set_format(parg->next_header_id, ((PMQXQH)p_data)->MsgDesc.Format);
            }
            else
            {
                memcpy(((PMQXQH)p_data)->MsgDesc.Format, parg->data_format, MQ_FORMAT_LENGTH);
            }

            *(parg->p_data_offset) += sizeof(MQXQH);

            if(parg->trace_level>2)
                printf ("WMQ::Message#build_header data offset:%ld\n", (long)(*(parg->p_data_offset)));
        }
        else
        {
            rb_raise(rb_eArgError, "Unknown :header_type supplied in WMQ::Message#headers array");
        }
    }
    else
    {
        rb_raise(rb_eArgError, "Mandatory parameter :header_type missing from header entry in WMQ::Message#headers array");
    }

    return 0;                                         /* Continue */
}
